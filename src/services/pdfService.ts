// src/services/pdfService.ts
import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';
import type { 
  PDFExportOptions, 
  PDFExportResult, 
  PDFGenerationConfig,
  PDFTheme
} from '../types/pdf.types';

/**
 * Servi√ßo principal de exporta√ß√£o PDF
 */
export class PDFService {
  private static readonly DEFAULT_OPTIONS: PDFExportOptions = {
    format: 'A4',
    orientation: 'portrait',
    quality: 0.95,
    margin: {
      top: 10,
      right: 10,
      bottom: 10,
      left: 10
    }
  };

  /**
   * Exporta o curr√≠culo para PDF
   */
  static async exportToPDF(config: PDFGenerationConfig): Promise<PDFExportResult> {
    try {
      console.log('üöÄ Iniciando exporta√ß√£o PDF...');
      
      const { element, options, cvData } = config;
      const finalOptions = { ...this.DEFAULT_OPTIONS, ...options };
      
      // Preparar elemento para captura
      const preparedElement = await this.prepareElementForCapture(element, finalOptions.theme);
      
      // Log antes da captura
      console.log('üì∏ INICIANDO CAPTURA COM HTML2CANVAS...');
      console.log('üì∏ Elemento para captura:', preparedElement);
      console.log('üì∏ Dimens√µes:', preparedElement.offsetWidth, 'x', preparedElement.offsetHeight);
      console.log('üì∏ ScrollWidth/Height:', preparedElement.scrollWidth, 'x', preparedElement.scrollHeight);
      
      // Capturar como imagem com configura√ß√µes otimizadas
      const canvas = await html2canvas(preparedElement, {
        scale: 2, // Escala fixa para consist√™ncia
        useCORS: true,
        allowTaint: true,
        backgroundColor: '#ffffff',
        width: preparedElement.offsetWidth,
        height: preparedElement.offsetHeight,
        scrollX: 0,
        scrollY: 0,
        x: 0,
        y: 0,
        ignoreElements: (element) => {
          // Ignora elementos que podem causar problemas
          return element.classList.contains('export-button') || 
                 element.tagName === 'BUTTON';
        },
        onclone: (clonedDoc) => {
          console.log('üì∏ CLONE CRIADO PARA CAPTURA:', clonedDoc);
          // For√ßa estilos no documento clonado
          const clonedElements = clonedDoc.querySelectorAll('[style*="backgroundColor"]');
          console.log('üì∏ Elementos com background no clone:', clonedElements.length);
        }
      });
      
      console.log('üì∏ CAPTURA CONCLU√çDA! Canvas:', canvas.width, 'x', canvas.height);

      // Criar PDF
      const pdf = new jsPDF({
        orientation: finalOptions.orientation!,
        unit: 'mm',
        format: finalOptions.format!.toLowerCase() as 'a4' | 'letter'
      });

      // Dimens√µes da p√°gina PDF
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      
      // Calcular dimens√µes da imagem mantendo propor√ß√£o
      const imgWidth = pageWidth - (finalOptions.margin!.left + finalOptions.margin!.right);
      const imgHeight = (canvas.height * imgWidth) / canvas.width;

      // Adicionar imagem ao PDF
      const imgData = canvas.toDataURL('image/jpeg', finalOptions.quality);
      pdf.addImage(
        imgData, 
        'JPEG', 
        finalOptions.margin!.left, 
        finalOptions.margin!.top, 
        imgWidth, 
        Math.min(imgHeight, pageHeight - (finalOptions.margin!.top + finalOptions.margin!.bottom))
      );

      // Se a imagem for muito alta, adicionar p√°ginas
      if (imgHeight > pageHeight - (finalOptions.margin!.top + finalOptions.margin!.bottom)) {
        const pages = Math.ceil(imgHeight / (pageHeight - (finalOptions.margin!.top + finalOptions.margin!.bottom)));
        console.log(`üìÑ Criando ${pages} p√°ginas para o PDF`);
        
        for (let i = 1; i < pages; i++) {
          pdf.addPage();
          const yOffset = -i * (pageHeight - (finalOptions.margin!.top + finalOptions.margin!.bottom));
          pdf.addImage(
            imgData, 
            'JPEG', 
            finalOptions.margin!.left, 
            finalOptions.margin!.top + yOffset, 
            imgWidth, 
            imgHeight
          );
        }
      }

      // Gerar nome do arquivo
      const filename = this.generateFilename(cvData.name, finalOptions.filename);
      
      // Fazer download
      pdf.save(filename);

      // Limpar elemento tempor√°rio
      this.cleanupElement(preparedElement);

      const fileSize = this.estimateFileSize(canvas);
      
      console.log('‚úÖ PDF exportado com sucesso!');
      return {
        success: true,
        filename,
        size: fileSize
      };

    } catch (error) {
      console.error('‚ùå Erro ao exportar PDF:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Erro desconhecido'
      };
    }
  }

  /**
   * Prepara o elemento para captura aplicando tema
   */
  private static async prepareElementForCapture(
    element: HTMLElement, 
    theme?: PDFTheme
  ): Promise<HTMLElement> {
    console.log('üìã PREPARANDO ELEMENTO PARA CAPTURA...');
    console.log('üìã Elemento original:', element);
    console.log('üìã Tema recebido:', theme?.name || 'Nenhum');
    
    // Clona o elemento para n√£o afetar o original
    const clonedElement = element.cloneNode(true) as HTMLElement;
    
    console.log('üìã Elemento clonado criado');
    console.log('üìã Elementos com style no clone:', clonedElement.querySelectorAll('[style]').length);
    
    // Aplica estilos para impress√£o
    clonedElement.style.position = 'absolute';
    clonedElement.style.left = '-9999px';
    clonedElement.style.top = '0';
    clonedElement.style.width = '210mm'; // A4 width
    clonedElement.style.minHeight = '297mm'; // A4 height
    clonedElement.style.backgroundColor = '#ffffff';
    clonedElement.style.padding = '20mm';
    clonedElement.style.boxSizing = 'border-box';
    clonedElement.style.fontFamily = 'system-ui, -apple-system, sans-serif';
    
    // NORMALIZA MARGENS NEGATIVAS QUE PODEM CAUSAR PROBLEMAS NO PDF
    this.fixNegativeMargins(clonedElement);
    
    // SEMPRE remove gradientes problem√°ticos ANTES de aplicar tema
    this.removeProblematicGradients(clonedElement);
    
    // Aplica tema se fornecido
    if (theme) {
      console.log('üìã APLICANDO TEMA:', theme.name);
      this.applyThemeToElement(clonedElement, theme);
      
      // Verifica se foi aplicado
      const elementsAfter = clonedElement.querySelectorAll('[style*="background"]');
      console.log('üìã Elementos com background ap√≥s tema:', elementsAfter.length);
      elementsAfter.forEach((el, i) => {
        if (el instanceof HTMLElement) {
          console.log(`üìã Elemento ${i}: background = ${el.style.backgroundColor}`);
        }
      });
    }

    // Adiciona ao DOM temporariamente
    document.body.appendChild(clonedElement);
    console.log('üìã Elemento adicionado ao DOM');
    
    // VERIFICA√á√ÉO FINAL ANTES DA CAPTURA
    console.log('üîç VERIFICA√á√ÉO FINAL DO ELEMENTO CLONADO:');
    console.log('üîç Elemento clonado:', clonedElement);
    console.log('üîç Tamanho do elemento clonado:', clonedElement.offsetWidth, 'x', clonedElement.offsetHeight);
    console.log('üîç HTML do elemento clonado:', clonedElement.innerHTML.slice(0, 1000));
    
    // Verifica e FOR√áA propriedades do H1 (nome)
    const h1Elements = clonedElement.querySelectorAll('h1');
    console.log('üîç H1s encontrados no clone:', h1Elements.length);
    h1Elements.forEach((h1, index) => {
      console.log(`üîç H1 ${index}:`, h1.textContent, '| Style:', h1.getAttribute('style'));
      
      if (h1 instanceof HTMLElement) {
        // FOR√áA propriedades para garantir que o nome apare√ßa
        h1.style.setProperty('color', '#ffffff', 'important');
        h1.style.setProperty('font-size', '36px', 'important');
        h1.style.setProperty('font-weight', '300', 'important');
        h1.style.setProperty('text-align', 'center', 'important');
        h1.style.setProperty('margin-bottom', '8px', 'important');
        h1.style.setProperty('display', 'block', 'important');
        h1.style.setProperty('visibility', 'visible', 'important');
        h1.style.setProperty('opacity', '1', 'important');
        h1.style.setProperty('font-family', 'Arial, sans-serif', 'important');
        
        // Se o texto for placeholder, for√ßa um nome vis√≠vel
        if (!h1.textContent || h1.textContent.trim() === '' || h1.textContent === 'Seu Nome') {
          h1.textContent = 'NOME DO USU√ÅRIO';
          console.log(`üîç H1 ${index} TEXTO CORRIGIDO PARA: NOME DO USU√ÅRIO`);
        }
        
        console.log(`üîç H1 ${index} FOR√áADO:`, h1.getAttribute('style'));
        console.log(`üîç H1 ${index} TEXTO FINAL:`, h1.textContent);
      }
    });
    
    // Verifica se tem o cabe√ßalho verde
    const headerElements = clonedElement.querySelectorAll('[style*="#6b7f5e"], [style*="backgroundColor"]');
    console.log('üîç Elementos com cor de fundo encontrados:', headerElements.length);
    headerElements.forEach((el, index) => {
      if (el instanceof HTMLElement) {
        console.log(`üîç Header ${index}:`, el.tagName, '| Style:', el.getAttribute('style'));
        console.log(`üîç Header ${index} conte√∫do:`, el.textContent?.slice(0, 100));
      }
    });
    
    // FOR√áA todas as linhas decorativas a serem suaves e vis√≠veis
    const allLines = clonedElement.querySelectorAll('[style*="height: 1px"], [style*="height:1px"], [style*="rgba(255,255,255,0.3)"], [style*="height: 2px"]');
    console.log('üîç Linhas decorativas encontradas:', allLines.length);
    allLines.forEach((line, index) => {
      if (line instanceof HTMLElement) {
        console.log(`üìè MELHORANDO LINHA ${index}:`, line.getAttribute('style'));
        
        // Linha suave e elegante
        line.style.setProperty('background-color', 'rgba(255,255,255,0.7)', 'important');
        line.style.setProperty('height', '1px', 'important');
        line.style.setProperty('display', 'block', 'important');
        line.style.setProperty('width', '100%', 'important');
        line.style.setProperty('opacity', '0.7', 'important');
        line.style.setProperty('border', 'none', 'important');
        line.style.setProperty('border-radius', '0px', 'important');
        line.style.setProperty('box-shadow', '0 0 1px rgba(255,255,255,0.3)', 'important');
        line.style.setProperty('margin', '20px 0', 'important');
        
        console.log(`üìè LINHA ${index} MELHORADA PARA SUAVIDADE`);
      }
    });
    
    // Aguarda um momento para renderiza√ß√£o
    await new Promise(resolve => setTimeout(resolve, 200));
    
    return clonedElement;
  }

  /**
   * Corrige margens negativas que podem causar problemas na captura
   */
  private static fixNegativeMargins(element: HTMLElement): void {
    console.log('üîß CORRIGINDO MARGENS NEGATIVAS...');
    
    // Procura por todos os elementos com margens negativas
    const allElements = element.querySelectorAll('*');
    allElements.forEach((el, index) => {
      if (el instanceof HTMLElement) {
        const style = el.getAttribute('style') || '';
        
        // Se tem margens negativas
        if (style.includes('marginLeft: -') || style.includes('marginRight: -') || 
            style.includes('marginTop: -') || style.includes('margin: -')) {
          
          console.log(`üîß Elemento ${index} com margens negativas encontrado:`, style);
          
          // Se √© o cabe√ßalho principal (tem backgroundColor)
          if (style.includes('backgroundColor') || style.includes('#6b7f5e')) {
            console.log(`üîß CORRIGINDO CABE√áALHO: removendo margens negativas`);
            
            // Remove margens negativas e ajusta para funcionar bem no PDF
            el.style.marginLeft = '0px';
            el.style.marginRight = '0px';
            el.style.marginTop = '0px';
            
            // Garante que o cabe√ßalho ocupe toda a largura
            el.style.width = '100%';
            el.style.boxSizing = 'border-box';
            
            console.log(`üîß CABE√áALHO CORRIGIDO:`, el.getAttribute('style'));
          }
        }
      }
    });
  }

  /**
   * Aplica cores especificamente no cabe√ßalho PersonalHeader
   */
  private static applyHeaderTheme(element: HTMLElement, theme: PDFTheme): void {
    console.log('üéØ APLICANDO TEMA ESPEC√çFICO NO CABE√áALHO...');
    
    // Procura especificamente pelo padr√£o do PersonalHeader
    // 1. Busca por elementos que t√™m a cor verde espec√≠fica (#6b7f5e)
    const greenElements = element.querySelectorAll('*');
    let headerFound = false;
    
    greenElements.forEach((el, index) => {
      if (el instanceof HTMLElement) {
        const style = el.getAttribute('style') || '';
        const computedStyle = window.getComputedStyle(el);
        
        // Verifica se tem a cor verde do header
        if (style.includes('#6b7f5e') || style.includes('backgroundColor') || 
            computedStyle.backgroundColor === 'rgb(107, 127, 94)') {
          
          console.log(`üéØ HEADER ENCONTRADO ${index}!`);
          console.log(`üéØ Style original: ${style}`);
          console.log(`üéØ Background computado: ${computedStyle.backgroundColor}`);
          
          // Aplica a nova cor
          el.style.setProperty('background-color', theme.colors.primary, 'important');
          el.style.setProperty('color', theme.colors.headerText, 'important');
          
          // Procura por elementos filhos que s√£o a linha branca
          const children = el.querySelectorAll('*');
          children.forEach((child) => {
            if (child instanceof HTMLElement) {
              const childStyle = child.getAttribute('style') || '';
              // Se √© a linha branca semi-transparente ou qualquer linha fina
              if (childStyle.includes('rgba(255,255,255,0.3)') || 
                  childStyle.includes('height: 1px') ||
                  childStyle.includes('height:1px') ||
                  (childStyle.includes('height') && childStyle.includes('1px'))) {
                console.log(`üéØ LINHA DECORATIVA ENCONTRADA: ${childStyle}`);
                
                // FOR√áA a linha a aparecer com cor mais vis√≠vel e espessura adequada
                child.style.setProperty('background-color', 'rgba(255,255,255,0.8)', 'important');
                child.style.setProperty('height', '2px', 'important');
                child.style.setProperty('width', '100%', 'important');
                child.style.setProperty('display', 'block', 'important');
                child.style.setProperty('border', 'none', 'important');
                child.style.setProperty('margin', '20px 0', 'important');
                
                console.log(`üéØ LINHA FOR√áADA: altura=2px, cor=rgba(255,255,255,0.8)`);
              }
            }
          });
          
          // Se n√£o encontrou a linha decorativa, cria uma nova
          const existingLine = el.querySelector('[style*="height: 1px"], [style*="height:1px"]');
          if (!existingLine) {
            console.log(`üéØ CRIANDO LINHA DECORATIVA NOVA`);
            const decorativeLine = document.createElement('div');
            decorativeLine.style.setProperty('height', '2px', 'important');
            decorativeLine.style.setProperty('background-color', 'rgba(255,255,255,0.8)', 'important');
            decorativeLine.style.setProperty('width', '100%', 'important');
            decorativeLine.style.setProperty('margin', '20px 0', 'important');
            decorativeLine.style.setProperty('display', 'block', 'important');
            
            // Insere a linha ap√≥s o H1 (nome)
            const h1 = el.querySelector('h1');
            if (h1 && h1.parentNode) {
              h1.parentNode.insertBefore(decorativeLine, h1.nextSibling);
              console.log(`üéØ LINHA DECORATIVA INSERIDA AP√ìS H1`);
            }
          }
          
          headerFound = true;
          console.log(`üéØ HEADER TEMA APLICADO: ${theme.colors.primary}`);
        }
      }
    });
    
    if (!headerFound) {
      console.log('üéØ HEADER N√ÉO ENCONTRADO - usando estrat√©gia alternativa');
      
      // Estrat√©gia alternativa: procura por H1 (t√≠tulo do nome)
      const h1Elements = element.querySelectorAll('h1');
      h1Elements.forEach((h1) => {
        if (h1.parentElement && h1.parentElement instanceof HTMLElement) {
          console.log('üéØ APLICANDO TEMA VIA H1 PARENT');
          h1.parentElement.style.setProperty('background-color', theme.colors.primary, 'important');
          h1.parentElement.style.setProperty('color', theme.colors.headerText, 'important');
        }
      });
    }
  }

  /**
   * Remove gradientes problem√°ticos que causam erro no html2canvas
   */
  private static removeProblematicGradients(element: HTMLElement): void {
    console.log('üîß Removendo gradientes problem√°ticos...');
    
    // Remove TODOS os gradientes inline que causam problema no html2canvas
    const elementsWithGradients = element.querySelectorAll('[style*="linear-gradient"], [style*="radial-gradient"], [style*="conic-gradient"]');
    elementsWithGradients.forEach((el, index) => {
      if (el instanceof HTMLElement) {
        const currentStyle = el.style.background || el.style.backgroundImage;
        console.log(`üîß Elemento ${index} com gradiente encontrado:`, currentStyle);
        
        // Substitui por cor s√≥lida segura
        el.style.background = '#6b7f5e'; // Verde padr√£o
        el.style.backgroundImage = 'none';
        el.style.setProperty('background', '#6b7f5e', 'important');
        el.style.setProperty('background-image', 'none', 'important');
        
        console.log(`‚úÖ Gradiente ${index} removido e substitu√≠do por cor s√≥lida`);
      }
    });
    
    // Remove gradientes em classes CSS problem√°ticas
    const gradientClasses = element.querySelectorAll('[class*="gradient"], [class*="bg-gradient"]');
    gradientClasses.forEach((el, index) => {
      if (el instanceof HTMLElement) {
        el.style.background = '#6b7f5e';
        el.style.backgroundImage = 'none';
        el.style.setProperty('background', '#6b7f5e', 'important');
        el.style.setProperty('background-image', 'none', 'important');
        console.log(`‚úÖ Classe gradiente ${index} neutralizada`);
      }
    });
  }

  /**
   * Aplica tema ao elemento clonado
   */
  private static applyThemeToElement(element: HTMLElement, theme: PDFTheme): void {
    console.log('üé® Aplicando tema:', theme.name);
    console.log('üé® Cores do tema:', theme.colors);
    
    // ESTRAT√âGIA ESPEC√çFICA: Procura pelo padr√£o do PersonalHeader
    this.applyHeaderTheme(element, theme);
    
    // 1. ESTRAT√âGIA M√öLTIPLA para encontrar o cabe√ßalho
    
    // Busca A: Elementos com backgroundColor inline
    const headerElements1 = element.querySelectorAll('[style*="backgroundColor"]');
    console.log('üé® M√©todo A - backgroundColor encontrados:', headerElements1.length);
    
    // Busca B: Elementos com background-color inline  
    const headerElements2 = element.querySelectorAll('[style*="background-color"]');
    console.log('üé® M√©todo B - background-color encontrados:', headerElements2.length);
    
    // Busca C: Busca por cor espec√≠fica do verde padr√£o
    const headerElements3 = element.querySelectorAll('[style*="#6b7f5e"], [style*="rgb(107, 127, 94)"]');
    console.log('üé® M√©todo C - cor verde espec√≠fica encontrados:', headerElements3.length);
    
    // Busca D: Todos os divs com style (for√ßa bruta)
    const allDivs = element.querySelectorAll('div[style]');
    console.log('üé® M√©todo D - divs com style encontrados:', allDivs.length);
    
    // Combina todos os resultados
    const allHeaderElements = new Set([
      ...Array.from(headerElements1),
      ...Array.from(headerElements2), 
      ...Array.from(headerElements3)
    ]);
    
    console.log('üé® Total de elementos √∫nicos para aplicar cor:', allHeaderElements.size);
    
    // Aplica cor em todos os elementos encontrados
    allHeaderElements.forEach((el, index) => {
      if (el instanceof HTMLElement) {
        const oldBg = el.style.backgroundColor;
        const oldColor = el.style.color;
        
        // For√ßa aplica√ß√£o da cor (remove !important pois n√£o funciona em style inline)
        el.style.setProperty('background-color', theme.colors.primary, 'important');
        el.style.setProperty('color', theme.colors.headerText, 'important');
        
        console.log(`üé® Header ${index}: ${oldBg} ‚Üí ${theme.colors.primary}`);
        console.log(`üé® Header texto ${index}: ${oldColor} ‚Üí ${theme.colors.headerText}`);
      }
    });
    
    // FOR√áA BRUTA: Procura por QUALQUER elemento com a cor verde padr√£o
    allDivs.forEach((div, index) => {
      if (div instanceof HTMLElement) {
        const style = div.getAttribute('style') || '';
        if (style.includes('#6b7f5e') || style.includes('backgroundColor') || style.includes('background-color')) {
          console.log(`üé® FOR√áA BRUTA ${index}: Encontrado elemento suspeito`);
          console.log(`üé® FOR√áA BRUTA ${index}: Style = ${style}`);
          
          // M√∫ltiplas tentativas de aplicar a cor
          div.style.backgroundColor = theme.colors.primary;
          div.style.setProperty('background-color', theme.colors.primary, 'important');
          div.setAttribute('style', style.replace('#6b7f5e', theme.colors.primary));
          
          div.style.color = theme.colors.headerText;
          div.style.setProperty('color', theme.colors.headerText, 'important');
          
          console.log(`üé® FOR√áA BRUTA ${index}: Aplicado ${theme.colors.primary}`);
          console.log(`üé® FOR√áA BRUTA ${index}: Novo style = ${div.getAttribute('style')}`);
        }
      }
    });
    
    // SUPER FOR√áA BRUTA: Se nada funcionou, procura especificamente por divs que cont√™m texto como "Nome"
    const textDivs = element.querySelectorAll('div');
    textDivs.forEach((div, index) => {
      if (div instanceof HTMLElement && div.textContent && 
          (div.textContent.includes('Nome') || div.textContent.includes('email') || div.textContent.includes('@'))) {
        const parent = div.parentElement;
        if (parent && parent.style && parent.style.backgroundColor) {
          console.log(`üé® SUPER FOR√áA BRUTA ${index}: Encontrado div com texto relevante`);
          console.log(`üé® SUPER FOR√áA BRUTA ${index}: Parent background = ${parent.style.backgroundColor}`);
          
          parent.style.setProperty('background-color', theme.colors.primary, 'important');
          parent.style.setProperty('color', theme.colors.headerText, 'important');
          
          console.log(`üé® SUPER FOR√áA BRUTA ${index}: Aplicado no parent`);
        }
      }
    });

    // MEGA FOR√áA BRUTA: Procura por QUALQUER div com cor de fundo e aplica o tema
    const allElementsWithBg = element.querySelectorAll('*');
    allElementsWithBg.forEach((el, index) => {
      if (el instanceof HTMLElement) {
        const computedStyle = window.getComputedStyle(el);
        const bgColor = computedStyle.backgroundColor;
        
        // Se tem cor de fundo que n√£o √© transparente/branca
        if (bgColor && bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent' && bgColor !== 'rgb(255, 255, 255)') {
          console.log(`üé® MEGA FOR√áA BRUTA ${index}: Elemento com background detectado`);
          console.log(`üé® MEGA FOR√áA BRUTA ${index}: Background = ${bgColor}`);
          console.log(`üé® MEGA FOR√áA BRUTA ${index}: Tag = ${el.tagName}`);
          
          // Se √© um elemento de cabe√ßalho (cont√©m texto ou est√° em posi√ß√£o de header)
          if (el.textContent && (el.textContent.includes('Nome') || el.textContent.includes('@') || 
              el.getBoundingClientRect().top < 200)) {
            el.style.setProperty('background-color', theme.colors.primary, 'important');
            el.style.setProperty('color', theme.colors.headerText, 'important');
            console.log(`üé® MEGA FOR√áA BRUTA ${index}: Aplicado tema no elemento`);
          }
        }
      }
    });

    // 2. Remove gradientes problem√°ticos e aplica cores s√≥lidas
    const gradientElements = element.querySelectorAll('[class*="gradient"], [style*="gradient"], [class*="bg-gradient"]');
    gradientElements.forEach((el, index) => {
      if (el instanceof HTMLElement) {
        // Remove gradientes e aplica cor s√≥lida
        el.style.background = theme.colors.sectionBg;
        el.style.backgroundImage = 'none';
        el.style.setProperty('background', theme.colors.sectionBg, 'important');
        el.style.setProperty('background-image', 'none', 'important');
        console.log(`üé® Gradiente/Fundo ${index}: aplicado ${theme.colors.sectionBg}`);
      }
    });

    // 3. Remove TODOS os gradientes inline perigosos para html2canvas
    const allElementsWithStyle = element.querySelectorAll('[style*="linear-gradient"], [style*="radial-gradient"], [style*="conic-gradient"]');
    allElementsWithStyle.forEach((el, index) => {
      if (el instanceof HTMLElement) {
        // Substitui gradientes por cor s√≥lida baseada no tema
        el.style.background = theme.colors.primary;
        el.style.backgroundImage = 'none';
        el.style.setProperty('background', theme.colors.primary, 'important');
        el.style.setProperty('background-image', 'none', 'important');
        console.log(`üîß Gradiente inline ${index}: removido e substitu√≠do por cor s√≥lida`);
      }
    });

    // 4. Aplica cor de fundo geral
    element.style.backgroundColor = theme.colors.background;
    element.style.color = theme.colors.text;
    
    // 5. Aplica cores nos t√≠tulos das se√ß√µes (H1, H2, H3, etc)
    const headings = element.querySelectorAll('h1, h2, h3, h4, h5, h6');
    headings.forEach((heading, index) => {
      if (heading instanceof HTMLElement) {
        heading.style.color = theme.colors.primary;
        console.log(`üé® T√≠tulo ${index}: aplicado ${theme.colors.primary}`);
      }
    });

    // 5. Aplica cor em elementos com bordas coloridas
    const coloredBorders = element.querySelectorAll('[class*="border-"], [style*="border-color"]');
    coloredBorders.forEach((el, index) => {
      if (el instanceof HTMLElement) {
        el.style.borderColor = theme.colors.accent;
        console.log(`üé® Borda ${index}: aplicado ${theme.colors.accent}`);
      }
    });

    // 6. Aplica cor em elementos de destaque espec√≠ficos
    const accentElements = element.querySelectorAll('[class*="text-blue"], [class*="text-purple"], [class*="bg-blue"], [class*="bg-purple"]');
    accentElements.forEach((el, index) => {
      if (el instanceof HTMLElement) {
        // Se √© um fundo, aplica cor de fundo
        if (el.className.includes('bg-')) {
          el.style.backgroundColor = theme.colors.sectionBg;
        } else {
          // Se √© texto, aplica cor de destaque
          el.style.color = theme.colors.accent;
        }
        console.log(`üé® Elemento destaque ${index}: aplicado tema`);
      }
    });

    // 7. Aplica cores em barras de progresso (se houver)
    const progressBars = element.querySelectorAll('[class*="progress"], [class*="bar"]');
    progressBars.forEach((el, index) => {
      if (el instanceof HTMLElement) {
        el.style.backgroundColor = theme.colors.accent;
        console.log(`üé® Barra de progresso ${index}: aplicado ${theme.colors.accent}`);
      }
    });
  }

  /**
   * Remove elemento tempor√°rio do DOM
   */
  private static cleanupElement(element: HTMLElement): void {
    if (element.parentNode) {
      element.parentNode.removeChild(element);
    }
  }

  /**
   * Gera nome do arquivo baseado no nome do usu√°rio
   */
  private static generateFilename(userName: string, customFilename?: string): string {
    if (customFilename) {
      return customFilename.endsWith('.pdf') ? customFilename : `${customFilename}.pdf`;
    }
    
    const cleanName = userName
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '') // Remove acentos
      .replace(/[^a-z0-9]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
    
    const timestamp = new Date().toISOString().split('T')[0];
    return `curriculo-${cleanName || 'usuario'}-${timestamp}.pdf`;
  }

  /**
   * Estima o tamanho do arquivo gerado
   */
  private static estimateFileSize(canvas: HTMLCanvasElement): string {
    const bytes = (canvas.width * canvas.height * 4) * 0.3; // Estimativa
    if (bytes < 1024 * 1024) {
      return `${Math.round(bytes / 1024)}KB`;
    }
    return `${(bytes / (1024 * 1024)).toFixed(1)}MB`;
  }

  /**
   * Valida se o elemento pode ser exportado
   */
  static validateElement(element: HTMLElement): boolean {
    return !!(element && element.offsetWidth > 0 && element.offsetHeight > 0);
  }
}

/**
 * Fun√ß√£o helper para exporta√ß√£o r√°pida
 */
export async function exportCVToPDF(
  element: HTMLElement,
  cvData: { name: string; email: string; phone: string },
  options?: PDFExportOptions
): Promise<PDFExportResult> {
  return PDFService.exportToPDF({
    element,
    cvData,
    options: options || {}
  });
}
